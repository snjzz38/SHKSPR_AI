<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AI Citation Generator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/favicon.png">
    <style>
        :root {
            --bg-primary: #000; --bg-secondary: #111; --text-primary: #fff;
            --accent: #fff; --card-bg: #222; --link-hover: #ffffff;
            --accent-rgb: 255, 255, 255;
        }
        body.theme-cyan { --bg-primary: #000; --bg-secondary: #0b0b0b; --text-primary: #e0ffff; --accent: #00f6ff; --card-bg: #072a2c; --accent-rgb: 0, 246, 255; }
        body.theme-purple { --bg-primary: #0d001a; --bg-secondary: #14002b; --text-primary: #ffe6ff; --accent: #cc66ff; --card-bg: #1d0036; --accent-rgb: 204, 102, 255; }
        body.theme-green { --bg-primary: #001a00; --bg-secondary: #002b00; --text-primary: #e6ffe6; --accent: #66ff66; --card-bg: #003600; --accent-rgb: 102, 255, 102; }
        body.theme-blackwhite { --bg-primary: #000; --bg-secondary: #111; --text-primary: #fff; --accent: #e0e0e0; --card-bg: #222; --accent-rgb: 224, 224, 224; }
        body.theme-red { --bg-primary: #1a0000; --bg-secondary: #2b0000; --text-primary: #ffe6e6; --accent: #ff3333; --card-bg: #360000; --accent-rgb: 255, 51, 51; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Segoe UI', Arial, sans-serif; background: var(--bg-primary); color: var(--text-primary); min-height: 100vh; transition: background-color 0.6s, color 0.6s; display: flex; flex-direction: column; overflow-x: hidden; }
        .main-content { width: 100%; display: flex; flex-direction: column; align-items: center; flex-grow: 1; }
        .hero { text-align: center; padding: 50px 20px 30px; position: relative; z-index: 5; }
        .hero h1 { font-size: 3.2rem; text-shadow: 0 0 10px var(--accent), 0 0 20px var(--accent), 0 0 30px var(--accent); margin-bottom: 20px; }
        .hero p { font-size: 1.2rem; margin: 0 auto 30px; max-width: 600px; }
        .container { max-width: 900px; width: 90%; margin: 20px auto 40px auto; padding: 20px; background-color: var(--bg-secondary); border-radius: 12px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3); display: flex; flex-direction: column; gap: 20px; position: relative; }
        .container h2 { font-size: 1.5rem; color: var(--text-primary); text-align: center; margin-bottom: 5px; }
        .form-row { display: flex; flex-wrap: wrap; gap: 20px; align-items: flex-end; }
        .form-group { flex: 1 1 200px; display: flex; flex-direction: column; gap: 5px; }
        .form-group label { font-size: 0.9rem; font-weight: bold; }
        textarea, select, input[type="number"] { width: 100%; padding: 15px; border: 1px solid var(--accent); border-radius: 8px; background-color: var(--card-bg); color: var(--text-primary); font-size: 1rem; resize: vertical; min-height: 54px; transition: border-color 0.3s, background-color 0.3s; }
        textarea { min-height: 150px; }
        textarea:focus, select:focus, input[type="number"]:focus { outline: none; border-color: var(--text-primary); box-shadow: 0 0 10px rgba(var(--accent-rgb), 0.5); }
        .radio-group { display: flex; gap: 15px; background-color: var(--card-bg); border: 1px solid var(--accent); padding: 10px 15px; border-radius: 8px; align-items: center; height: 54px; }
        .radio-group label { cursor: pointer; display: flex; align-items: center; gap: 5px; }
        .action-buttons { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; }
        .generate-button, .secondary-button { background-color: var(--accent); color: var(--bg-primary); border: none; padding: 12px 25px; border-radius: 25px; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 10px rgba(var(--accent-rgb), 0.4); }
        .generate-button:hover, .secondary-button:hover { transform: translateY(-2px); box-shadow: 0 6px 15px rgba(var(--accent-rgb), 0.6); }
        .generate-button:disabled { background-color: var(--card-bg); color: rgba(var(--accent-rgb), 0.5); cursor: not-allowed; box-shadow: none; }
        .secondary-button { background-color: transparent; color: var(--accent); border: 2px solid var(--accent); box-shadow: none; }
        .secondary-button:hover { background-color: var(--accent); color: var(--bg-primary); box-shadow: 0 6px 15px rgba(var(--accent-rgb), 0.6); }
        .message-box { padding: 15px; border-radius: 8px; text-align: center; margin-top: 20px; font-size: 1rem; display: none; border: 1px solid; }
        .message-box.info { background-color: rgba(var(--accent-rgb), 0.1); border-color: var(--accent); color: var(--text-primary); }
        .message-box.error { background-color: rgba(239, 68, 68, 0.1); border-color: #fecaca; color: #fecaca; }
        .loading-bar-container { width: 100%; height: 8px; background-color: var(--card-bg); border-radius: 4px; overflow: hidden; margin-top: 10px; display: none; }
        .loading-bar { height: 100%; width: 0%; background-color: var(--accent); border-radius: 4px; transition: width 0.4s ease-in-out; }
        #output-section { margin-top: 20px; display: none; }
        #output-area { list-style: none; padding: 0; }
        .citation-item { background-color: var(--card-bg); border: 1px solid var(--accent); border-radius: 8px; padding: 15px; margin-bottom: 15px; font-size: 0.9rem; line-height: 1.6; }
        footer.main-footer { width: 100%; text-align: center; padding: 20px; font-size: 0.9rem; background-color: var(--bg-secondary); position: relative; z-index: 10; }
    </style>
</head>
<body>
    <div id="header-container"></div>
    <main class="main-content">
        <section class="hero">
            <h1>AI Citation Generator</h1>
            <p>Paste your essay, and this tool will find sources and generate citations for you.</p>
        </section>
        <div class="container">
            <div class="form-row">
                <div class="form-group" style="flex: 2 1 200px;">
                    <label for="citation-style">Citation Style</label>
                    <select id="citation-style">
                        <option value="apa7">APA 7th Edition</option>
                        <option value="mla9">MLA 9th Edition</option>
                        <option value="chicago">Chicago (Author-Date)</option>
                    </select>
                </div>
                <div class="form-group" style="flex: 1 1 150px;">
                    <label for="citation-count">Max Citations</label>
                    <select id="citation-count">
                        <option value="auto">Auto</option>
                        <option value="custom">Custom...</option>
                    </select>
                </div>
                <div class="form-group" style="flex: 2 1 200px;">
                    <label>Output Type</label>
                    <div class="radio-group">
                        <label><input type="radio" name="output-type" value="bibliography" checked><span>Bibliography</span></label>
                        <label><input type="radio" name="output-type" value="in-text"><span>In-text</span></label>
                    </div>
                </div>
            </div>
            <div id="custom-count-container" style="display: none; margin-top: -10px;">
                <div class="form-group" id="custom-count-group">
                    <label for="custom-citation-count">Custom Number of Citations</label>
                    <input type="number" id="custom-citation-count" min="1" value="5" placeholder="Enter number...">
                </div>
            </div>
            <div class="form-group">
                <label for="essay-input">Paste your essay here</label>
                <textarea id="essay-input" rows="10" placeholder="Paste your text here..."></textarea>
            </div>
            <div class="action-buttons">
                <button id="generate-btn" class="generate-button">Generate Citations</button>
                <button id="clear-btn" class="secondary-button">Clear All</button>
            </div>
            <div id="loading-bar-container" class="loading-bar-container">
                <div id="loading-bar" class="loading-bar"></div>
            </div>
            <div id="messageBox" class="message-box"></div>
            <div id="output-section">
                <div id="in-text-output-container" style="display: none; margin-bottom: 30px;">
                    <h2>Essay with In-Text Citations</h2>
                    <div id="in-text-output-area" class="citation-item" style="white-space: pre-wrap; line-height: 1.8; text-align: left;"></div>
                    <div class="action-buttons" style="margin-top: 15px;"><button id="copy-essay-btn" class="secondary-button">Copy Essay</button></div>
                </div>
                <h2 id="output-heading">Bibliography</h2>
                <ul id="output-area"></ul>
                <div class="action-buttons" style="margin-top: 15px;"><button id="copy-biblio-btn" class="secondary-button">Copy Bibliography</button></div>
            </div>
        </div>
    </main>
    <footer class="main-footer"><p>&copy; 2025 Shkspr. All rights reserved.</p></footer>

    <script>
        // --- CONFIGURATION & SYSTEM PROMPTS ---
        let GEMINI_API_KEY = null; // This will be fetched from a file
        const ALL_GEMINI_MODELS = [
            'gemini-2.5-flash-lite', 'gemini-2.5-flash', 'gemini-2.0-flash',
            'gemini-2.0-flash-lite', 'gemini-1.5-flash', 'gemini-1.5-flash-8b',
        ];

        const PROMPT_GENERATE_SEARCH_QUERY = (essayText) => `
            Summarize the following text into a single, concise search query of 10-15 words. 
            The query should be ideal for finding academic and authoritative sources related to the text's main arguments.
            Return ONLY the search query string.
            Text: "${essayText}"
        `;

        const PROMPT_EXTRACT_CITATION_DATA = (fetchedContents) => `
            You are a data extraction expert. Your task is to extract citation information from the provided webpage data.
            RULES:
            1. Analyze the "Webpage Data" to find the author, title, and publication year for each source.
            2. CRITICAL RULE: You MUST make a best effort to find an author. If a person's name is not available, use the organization or website name (e.g., 'World Health Organization', 'BBC News'). Do NOT leave the author field blank.
            3. For the 'year', extract it from the 'published_date' field or the text. If no year can be found, use "n.d.".
            4. CRITICAL QUALITY RULE: If a source is missing a clear title, you MUST DISCARD it. A source without a title is not citable.
            5. Return ONLY a valid JSON array of objects. Each object must have these exact keys: "author", "title", "year", "url".

            Webpage Data:
            ${JSON.stringify(fetchedContents, null, 2)}
        `;

        const PROMPT_FORMAT_BIBLIOGRAPHY = (structuredCitations, citationStyle, countInstruction) => `
            You are an expert academic librarian. Your only task is to format the provided JSON data into a bibliography.
            RULES:
            1. Format ALL citations in **${citationStyle.toUpperCase()}** style.
            2. Order the final citations **alphabetically** by author.
            3. ${countInstruction}
            4. Return ONLY a valid JSON array of strings. Each string should be a complete, formatted citation.

            Source Data:
            ${JSON.stringify(structuredCitations, null, 2)}
        `;

        const PROMPT_INSERT_IN_TEXT_CITATIONS = (citations, essayText, citationStyle) => `
            You are an expert academic editor. Your primary goal is to insert correct and comprehensive in-text citations into an essay.
            RULES:
            1. Carefully read the "Original Essay" and the "Bibliography" provided.
            2. Your main task is to connect the claims in the essay to the sources in the bibliography.
            3. **CRITICAL CITATION RULE:** You MUST insert an in-text citation for **EVERY** source in the bibliography wherever its information could possibly apply. Be generous and comprehensive with citations. It is better to over-cite than to under-cite.
            4. The in-text citations MUST be in the correct **${citationStyle.toUpperCase()}** format.
            5. **CRITICAL PRESERVATION RULE:** You must NOT change, rephrase, or alter the original essay text in any other way. Preserve it exactly as it is.
            6. Before finishing, review the essay one last time to ensure all relevant sources from the bibliography have been cited.
            7. Return ONLY the modified essay text as a single string.

            Bibliography:
            ${JSON.stringify(citations, null, 2)}

            Original Essay:
            "${essayText}"
        `;

        // --- APPLICATION LOGIC ---
        function initializeCitationApp() {
            const dom = {
                essayInput: document.getElementById('essay-input'),
                citationStyleSelect: document.getElementById('citation-style'),
                citationCountSelect: document.getElementById('citation-count'),
                customCountContainer: document.getElementById('custom-count-container'),
                customCitationCountInput: document.getElementById('custom-citation-count'),
                generateBtn: document.getElementById('generate-btn'),
                clearBtn: document.getElementById('clear-btn'),
                outputSection: document.getElementById('output-section'),
                outputArea: document.getElementById('output-area'),
                loadingBarContainer: document.getElementById('loading-bar-container'),
                loadingBar: document.getElementById('loading-bar'),
                messageBox: document.getElementById('messageBox'),
                outputHeading: document.getElementById('output-heading'),
                inTextOutputContainer: document.getElementById('in-text-output-container'),
                inTextOutputArea: document.getElementById('in-text-output-area'),
                copyEssayBtn: document.getElementById('copy-essay-btn'),
                copyBiblioBtn: document.getElementById('copy-biblio-btn'),
            };

            const shuffleArray = (array) => {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            };

            function showMessage(message, type = 'info') {
                dom.messageBox.className = `message-box ${type}`;
                dom.messageBox.textContent = message;
                dom.messageBox.style.display = 'block';
                setTimeout(() => { dom.messageBox.style.display = 'none'; }, 4000);
            }

            function startLoadingBar() {
                dom.loadingBarContainer.style.display = 'block';
                dom.loadingBar.style.width = '0%';
                setTimeout(() => { dom.loadingBar.style.width = '90%'; }, 100);
            }

            function stopLoadingBar(success = true) {
                dom.loadingBar.style.width = '100%';
                dom.loadingBar.style.backgroundColor = success ? 'var(--accent)' : '#fecaca';
                setTimeout(() => {
                    dom.loadingBarContainer.style.display = 'none';
                    dom.loadingBar.style.backgroundColor = 'var(--accent)';
                }, 500);
            }

            async function callGeminiApi(payload) {
                if (!GEMINI_API_KEY) throw new Error("API Key is not configured.");
                let modelsToTry = shuffleArray([...ALL_GEMINI_MODELS]);
                let lastError = null;
                for (const currentModel of modelsToTry) {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${currentModel}:generateContent?key=${GEMINI_API_KEY}`;
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({}));
                            throw new Error(`API call with ${currentModel} failed: ${errorData.error?.message || response.statusText}`);
                        }
                        const result = await response.json();
                        const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                        if (text && text.trim() !== '') return result;
                        throw new Error(`Model ${currentModel} returned an empty response.`);
                    } catch (error) {
                        console.warn(error.message);
                        lastError = error;
                    }
                }
                throw lastError || new Error("All API models failed.");
            }

            async function callBackendProxy(action, data) {
                const response = await fetch('/api/citation_proxy', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action, ...data })
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `Backend proxy failed for action: ${action}`);
                }
                return response.json();
            }

            async function processAndGenerate() {
                const essayText = dom.essayInput.value.trim();
                if (!essayText) {
                    showMessage('Please paste an essay into the input area.', 'error');
                    return;
                }
                dom.generateBtn.disabled = true;
                dom.outputSection.style.display = 'none';
                startLoadingBar();
                saveState();

                try {
                    // Step 1: Generate Search Query via Gemini
                    showMessage('Step 1/5: Generating search query...', 'info');
                    const queryPayload = { contents: [{ role: 'user', parts: [{ text: PROMPT_GENERATE_SEARCH_QUERY(essayText) }] }] };
                    const queryResult = await callGeminiApi(queryPayload);
                    const searchQuery = queryResult.candidates[0].content.parts[0].text.trim();

                    // Step 2: Search for sources via Backend Proxy
                    showMessage('Step 2/5: Finding relevant sources...', 'info');
                    const searchResult = await callBackendProxy('search', { query: searchQuery });
                    if (!searchResult.urls || searchResult.urls.length === 0) throw new Error("No relevant sources were found.");

                    // Step 3: Fetch content for each source via Backend Proxy
                    showMessage('Step 3/5: Fetching content from sources...', 'info');
                    const fetchedContents = (await Promise.all(
                        searchResult.urls.map(url => callBackendProxy('fetch', { url }))
                    )).filter(Boolean); // Filter out nulls from failed fetches
                    if (fetchedContents.length === 0) throw new Error("Could not fetch content from any sources.");

                    // Step 4: Extract structured data via Gemini
                    showMessage('Step 4/5: Analyzing sources for citation data...', 'info');
                    const extractionPayload = { contents: [{ role: 'user', parts: [{ text: PROMPT_EXTRACT_CITATION_DATA(fetchedContents) }] }], generationConfig: { responseMimeType: "application/json" } };
                    const extractionResult = await callGeminiApi(extractionPayload);
                    const structuredCitations = JSON.parse(extractionResult.candidates[0].content.parts[0].text);
                    if (!structuredCitations || structuredCitations.length === 0) throw new Error("Could not extract citable data from sources.");

                    // Step 5: Format bibliography and optionally add in-text citations
                    showMessage('Step 5/5: Generating final citations...', 'info');
                    const citationStyle = dom.citationStyleSelect.value;
                    const outputType = document.querySelector('input[name="output-type"]:checked').value;
                    let citationCount = dom.citationCountSelect.value;
                    if (citationCount === 'custom') citationCount = dom.customCitationCountInput.value || 5;
                    const countInstruction = citationCount === 'auto' ? `Return citations for all the provided sources.` : `Return exactly ${citationCount} citations. If there are fewer sources than requested, return all of them.`;

                    const formattingPayload = { contents: [{ role: 'user', parts: [{ text: PROMPT_FORMAT_BIBLIOGRAPHY(structuredCitations, citationStyle, countInstruction) }] }], generationConfig: { responseMimeType: "application/json" } };
                    const formattingResult = await callGeminiApi(formattingPayload);
                    const citations = JSON.parse(formattingResult.candidates[0].content.parts[0].text);

                    let inTextCitedEssay = null;
                    if (outputType === 'in-text') {
                        const inTextPayload = { contents: [{ role: 'user', parts: [{ text: PROMPT_INSERT_IN_TEXT_CITATIONS(citations, essayText, citationStyle) }] }] };
                        const inTextResult = await callGeminiApi(inTextPayload);
                        inTextCitedEssay = inTextResult.candidates[0].content.parts[0].text;
                    }

                    renderOutput({ citations, inTextCitedEssay }, outputType);
                    stopLoadingBar(true);
                    saveState(); // Save the successful results

                } catch (error) {
                    console.error('An error occurred:', error);
                    showMessage(`Error: ${error.message}`, 'error');
                    stopLoadingBar(false);
                } finally {
                    dom.generateBtn.disabled = false;
                }
            }
            
            function renderOutput(result, outputType) {
                dom.outputArea.innerHTML = '';
                dom.inTextOutputArea.textContent = '';
                dom.inTextOutputContainer.style.display = 'none';

                if (!Array.isArray(result.citations) || result.citations.length === 0) {
                    showMessage('No citable sources were found.', 'info');
                    dom.outputSection.style.display = 'none';
                    return;
                }

                if (outputType === 'in-text' && result.inTextCitedEssay) {
                    dom.inTextOutputArea.textContent = result.inTextCitedEssay;
                    dom.inTextOutputContainer.style.display = 'block';
                }

                result.citations.forEach(item => {
                    let citationText = (typeof item === 'string') ? item : (Object.values(item)[0] || '');
                    if (citationText.trim()) {
                        const listItem = document.createElement('li');
                        listItem.className = 'citation-item';
                        listItem.textContent = citationText;
                        dom.outputArea.appendChild(listItem);
                    }
                });

                dom.outputSection.style.display = 'block';
                showMessage('Citations generated successfully!', 'info');
            }

            // --- LOCALSTORAGE & STATE MANAGEMENT ---
            function saveState() {
                const state = {
                    essayText: dom.essayInput.value,
                    inTextCitedEssay: dom.inTextOutputArea.textContent,
                    citations: Array.from(dom.outputArea.querySelectorAll('.citation-item')).map(li => li.textContent)
                };
                localStorage.setItem('citationGeneratorState', JSON.stringify(state));
            }

            function loadState() {
                const savedState = localStorage.getItem('citationGeneratorState');
                if (!savedState) return;

                const state = JSON.parse(savedState);
                if (state.essayText) dom.essayInput.value = state.essayText;
                
                if (state.citations && state.citations.length > 0) {
                    const outputType = state.inTextCitedEssay ? 'in-text' : 'bibliography';
                    renderOutput({ citations: state.citations, inTextCitedEssay: state.inTextCitedEssay }, outputType);
                }
            }

            function clearState() {
                dom.essayInput.value = '';
                dom.outputSection.style.display = 'none';
                dom.inTextOutputArea.textContent = '';
                dom.outputArea.innerHTML = '';
                localStorage.removeItem('citationGeneratorState');
                showMessage('All content cleared.', 'info');
            }

            // --- EVENT LISTENERS ---
            dom.citationCountSelect.addEventListener('change', () => {
                dom.customCountContainer.style.display = (dom.citationCountSelect.value === 'custom') ? 'block' : 'none';
            });
            dom.generateBtn.addEventListener('click', processAndGenerate);
            dom.clearBtn.addEventListener('click', clearState);
            dom.essayInput.addEventListener('input', saveState);
            dom.copyEssayBtn.addEventListener('click', () => navigator.clipboard.writeText(dom.inTextOutputArea.textContent).then(() => showMessage('Essay copied!', 'info')));
            dom.copyBiblioBtn.addEventListener('click', () => {
                const text = Array.from(dom.outputArea.querySelectorAll('.citation-item')).map(li => li.textContent).join('\n\n');
                navigator.clipboard.writeText(text).then(() => showMessage('Bibliography copied!', 'info'));
            });

            // --- INITIAL SETUP ---
            (async () => {
                try {
                    const response = await fetch('Grok4.txt'); // Fetching API key from a local file
                    if (!response.ok) throw new Error('API key file not found.');
                    const key = (await response.text()).trim();
                    let output = "";
                    for (let i = 0; i < key.length; i++) { if ((i + 1) % 5 === 1) output += key[i]; }
                    GEMINI_API_KEY = output;
                } catch (error) {
                    showMessage('Could not load API Key. The application will not work.', 'error');
                    console.error(error);
                }
            })();
            loadState();
        }

        async function loadHeader() { /* Function to load shared header */ }
        document.addEventListener('DOMContentLoaded', () => {
            // loadHeader(); // You can uncomment this if you have a shared header file
            initializeCitationApp();
        });
    </script>
</body>
</html>
